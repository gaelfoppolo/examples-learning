\hypertarget{tree_8h}{}\section{types/tree.h File Reference}
\label{tree_8h}\index{types/tree.\+h@{types/tree.\+h}}
\subsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{struct____tree}{\+\_\+\+\_\+tree}
\begin{DoxyCompactList}\small\item\em Functions and structures used by the binary tree. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef struct \hyperlink{struct____tree}{\+\_\+\+\_\+tree} \hyperlink{tree_8h_abeafb453c4803982413917045332fc61}{Tree}
\begin{DoxyCompactList}\small\item\em Functions and structures used by the binary tree. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{tree_8h_abeafb453c4803982413917045332fc61}{Tree} $\ast$ \hyperlink{tree_8h_a23371a58349a9b88e641b1cfbf8ea88a}{create\+Leaf} (int id, char $\ast$str)
\begin{DoxyCompactList}\small\item\em Create a new leaf (tree) \end{DoxyCompactList}\item 
\hyperlink{tree_8h_abeafb453c4803982413917045332fc61}{Tree} $\ast$ \hyperlink{tree_8h_a801c4516159f77c6d1e5737d85f8aa1f}{create\+Node} (int id, char $\ast$str, \hyperlink{tree_8h_abeafb453c4803982413917045332fc61}{Tree} $\ast$left, \hyperlink{tree_8h_abeafb453c4803982413917045332fc61}{Tree} $\ast$right)
\begin{DoxyCompactList}\small\item\em Create a new node (tree) \end{DoxyCompactList}\item 
int \hyperlink{tree_8h_a13511abcf3d362ccaf18d3a8288e9a9c}{is\+Leaf} (\hyperlink{tree_8h_abeafb453c4803982413917045332fc61}{Tree} $\ast$t)
\begin{DoxyCompactList}\small\item\em Check if a tree is a leaf. \end{DoxyCompactList}\item 
\hyperlink{tree_8h_abeafb453c4803982413917045332fc61}{Tree} $\ast$ \hyperlink{tree_8h_a0a7a9c4c37381d59c0c406c8ce670a9c}{L\+CA} (\hyperlink{tree_8h_abeafb453c4803982413917045332fc61}{Tree} $\ast$root, int id1, int id2)
\begin{DoxyCompactList}\small\item\em Find the lowest common ancestor -\/ Complexity θ(n)  We traverse from root to leaf(s). When we find a node matching at least one, we pass it to its parent. The parent tests if left or right child contains the value. If yes, the parent is the L\+CA, else, we pass its parent, up to root. What is pass is the lower node or N\+U\+LL. \end{DoxyCompactList}\item 
void \hyperlink{tree_8h_a69fb3a3292bd8c145020d0fe58af26ba}{free\+Tree} (\hyperlink{tree_8h_abeafb453c4803982413917045332fc61}{Tree} $\ast$t)
\begin{DoxyCompactList}\small\item\em Remove from the memory, the space used by the tree. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Typedef Documentation}
\index{tree.\+h@{tree.\+h}!Tree@{Tree}}
\index{Tree@{Tree}!tree.\+h@{tree.\+h}}
\subsubsection[{\texorpdfstring{Tree}{Tree}}]{\setlength{\rightskip}{0pt plus 5cm}typedef struct {\bf \+\_\+\+\_\+tree}  {\bf Tree}}\hypertarget{tree_8h_abeafb453c4803982413917045332fc61}{}\label{tree_8h_abeafb453c4803982413917045332fc61}


Functions and structures used by the binary tree. 

F\+O\+P\+P\+O\+LO Gaël  P\+H\+I\+L\+IP Bastien Binary tree structure

id Integer that represents the value of the Node/\+Leaf  $\ast$left Pointer to left child  $\ast$right Pointer to right child 

\subsection{Function Documentation}
\index{tree.\+h@{tree.\+h}!create\+Leaf@{create\+Leaf}}
\index{create\+Leaf@{create\+Leaf}!tree.\+h@{tree.\+h}}
\subsubsection[{\texorpdfstring{create\+Leaf(int id, char $\ast$str)}{createLeaf(int id, char *str)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tree}$\ast$ create\+Leaf (
\begin{DoxyParamCaption}
\item[{int}]{id, }
\item[{char $\ast$}]{str}
\end{DoxyParamCaption}
)}\hypertarget{tree_8h_a23371a58349a9b88e641b1cfbf8ea88a}{}\label{tree_8h_a23371a58349a9b88e641b1cfbf8ea88a}


Create a new leaf (tree) 


\begin{DoxyParams}{Parameters}
{\em id} & Id of the value to store in the leaf \\
\hline
{\em str} & String that represents the real name of what is stored\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A new Tree
\end{DoxyReturn}
Create a new leaf (tree)

F\+O\+P\+P\+O\+LO Gaël  P\+H\+I\+L\+IP Bastien \index{tree.\+h@{tree.\+h}!create\+Node@{create\+Node}}
\index{create\+Node@{create\+Node}!tree.\+h@{tree.\+h}}
\subsubsection[{\texorpdfstring{create\+Node(int id, char $\ast$str, Tree $\ast$left, Tree $\ast$right)}{createNode(int id, char *str, Tree *left, Tree *right)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tree}$\ast$ create\+Node (
\begin{DoxyParamCaption}
\item[{int}]{id, }
\item[{char $\ast$}]{str, }
\item[{{\bf Tree} $\ast$}]{left, }
\item[{{\bf Tree} $\ast$}]{right}
\end{DoxyParamCaption}
)}\hypertarget{tree_8h_a801c4516159f77c6d1e5737d85f8aa1f}{}\label{tree_8h_a801c4516159f77c6d1e5737d85f8aa1f}


Create a new node (tree) 


\begin{DoxyParams}[1]{Parameters}
 & {\em id} & Id of the value to store in the Node \\
\hline
 & {\em str} & String that represents the real name of what is stored \\
\hline
\mbox{\tt in}  & {\em left} & The left child \\
\hline
\mbox{\tt in}  & {\em right} & The right child\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A new Tree 
\end{DoxyReturn}
\index{tree.\+h@{tree.\+h}!free\+Tree@{free\+Tree}}
\index{free\+Tree@{free\+Tree}!tree.\+h@{tree.\+h}}
\subsubsection[{\texorpdfstring{free\+Tree(\+Tree $\ast$t)}{freeTree(Tree *t)}}]{\setlength{\rightskip}{0pt plus 5cm}void free\+Tree (
\begin{DoxyParamCaption}
\item[{{\bf Tree} $\ast$}]{t}
\end{DoxyParamCaption}
)}\hypertarget{tree_8h_a69fb3a3292bd8c145020d0fe58af26ba}{}\label{tree_8h_a69fb3a3292bd8c145020d0fe58af26ba}


Remove from the memory, the space used by the tree. 


\begin{DoxyParams}{Parameters}
{\em t} & Pointer of the tree \\
\hline
\end{DoxyParams}
\index{tree.\+h@{tree.\+h}!is\+Leaf@{is\+Leaf}}
\index{is\+Leaf@{is\+Leaf}!tree.\+h@{tree.\+h}}
\subsubsection[{\texorpdfstring{is\+Leaf(\+Tree $\ast$t)}{isLeaf(Tree *t)}}]{\setlength{\rightskip}{0pt plus 5cm}int is\+Leaf (
\begin{DoxyParamCaption}
\item[{{\bf Tree} $\ast$}]{t}
\end{DoxyParamCaption}
)}\hypertarget{tree_8h_a13511abcf3d362ccaf18d3a8288e9a9c}{}\label{tree_8h_a13511abcf3d362ccaf18d3a8288e9a9c}


Check if a tree is a leaf. 


\begin{DoxyParams}{Parameters}
{\em t} & The tree to check\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 (false) ou 1 (true) 
\end{DoxyReturn}
\index{tree.\+h@{tree.\+h}!L\+CA@{L\+CA}}
\index{L\+CA@{L\+CA}!tree.\+h@{tree.\+h}}
\subsubsection[{\texorpdfstring{L\+C\+A(\+Tree $\ast$root, int id1, int id2)}{LCA(Tree *root, int id1, int id2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tree}$\ast$ L\+CA (
\begin{DoxyParamCaption}
\item[{{\bf Tree} $\ast$}]{root, }
\item[{int}]{id1, }
\item[{int}]{id2}
\end{DoxyParamCaption}
)}\hypertarget{tree_8h_a0a7a9c4c37381d59c0c406c8ce670a9c}{}\label{tree_8h_a0a7a9c4c37381d59c0c406c8ce670a9c}


Find the lowest common ancestor -\/ Complexity θ(n)  We traverse from root to leaf(s). When we find a node matching at least one, we pass it to its parent. The parent tests if left or right child contains the value. If yes, the parent is the L\+CA, else, we pass its parent, up to root. What is pass is the lower node or N\+U\+LL. 


\begin{DoxyParams}{Parameters}
{\em root} & The root of the tree \\
\hline
{\em id1} & The first value \\
\hline
{\em id2} & The second value\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The lowest common ancestor (node or leaf) 
\end{DoxyReturn}
