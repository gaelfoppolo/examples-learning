\hypertarget{tree_8c}{}\section{types/tree.c File Reference}
\label{tree_8c}\index{types/tree.\+c@{types/tree.\+c}}
{\ttfamily \#include $<$stdio.\+h$>$}\\*
{\ttfamily \#include $<$stdlib.\+h$>$}\\*
{\ttfamily \#include \char`\"{}tree.\+h\char`\"{}}\\*
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{tree_8h_abeafb453c4803982413917045332fc61}{Tree} $\ast$ \hyperlink{tree_8c_a23371a58349a9b88e641b1cfbf8ea88a}{create\+Leaf} (int id, char $\ast$str)
\begin{DoxyCompactList}\small\item\em Functions used by the binary tree. \end{DoxyCompactList}\item 
\hyperlink{tree_8h_abeafb453c4803982413917045332fc61}{Tree} $\ast$ \hyperlink{tree_8c_a801c4516159f77c6d1e5737d85f8aa1f}{create\+Node} (int id, char $\ast$str, \hyperlink{tree_8h_abeafb453c4803982413917045332fc61}{Tree} $\ast$left, \hyperlink{tree_8h_abeafb453c4803982413917045332fc61}{Tree} $\ast$right)
\begin{DoxyCompactList}\small\item\em Create a new node (tree) \end{DoxyCompactList}\item 
int \hyperlink{tree_8c_a13511abcf3d362ccaf18d3a8288e9a9c}{is\+Leaf} (\hyperlink{tree_8h_abeafb453c4803982413917045332fc61}{Tree} $\ast$t)
\begin{DoxyCompactList}\small\item\em Check if a tree is a leaf. \end{DoxyCompactList}\item 
\hyperlink{tree_8h_abeafb453c4803982413917045332fc61}{Tree} $\ast$ \hyperlink{tree_8c_a0a7a9c4c37381d59c0c406c8ce670a9c}{L\+CA} (\hyperlink{tree_8h_abeafb453c4803982413917045332fc61}{Tree} $\ast$root, int id1, int id2)
\begin{DoxyCompactList}\small\item\em Find the lowest common ancestor -\/ Complexity θ(n)  We traverse from root to leaf(s). When we find a node matching at least one, we pass it to its parent. The parent tests if left or right child contains the value. If yes, the parent is the L\+CA, else, we pass its parent, up to root. What is pass is the lower node or N\+U\+LL. \end{DoxyCompactList}\item 
void \hyperlink{tree_8c_a69fb3a3292bd8c145020d0fe58af26ba}{free\+Tree} (\hyperlink{tree_8h_abeafb453c4803982413917045332fc61}{Tree} $\ast$t)
\begin{DoxyCompactList}\small\item\em Remove from the memory, the space used by the tree. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Function Documentation}
\index{tree.\+c@{tree.\+c}!create\+Leaf@{create\+Leaf}}
\index{create\+Leaf@{create\+Leaf}!tree.\+c@{tree.\+c}}
\subsubsection[{\texorpdfstring{create\+Leaf(int id, char $\ast$str)}{createLeaf(int id, char *str)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tree}$\ast$ create\+Leaf (
\begin{DoxyParamCaption}
\item[{int}]{id, }
\item[{char $\ast$}]{str}
\end{DoxyParamCaption}
)}\hypertarget{tree_8c_a23371a58349a9b88e641b1cfbf8ea88a}{}\label{tree_8c_a23371a58349a9b88e641b1cfbf8ea88a}


Functions used by the binary tree. 

Create a new leaf (tree)

F\+O\+P\+P\+O\+LO Gaël  P\+H\+I\+L\+IP Bastien \index{tree.\+c@{tree.\+c}!create\+Node@{create\+Node}}
\index{create\+Node@{create\+Node}!tree.\+c@{tree.\+c}}
\subsubsection[{\texorpdfstring{create\+Node(int id, char $\ast$str, Tree $\ast$left, Tree $\ast$right)}{createNode(int id, char *str, Tree *left, Tree *right)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tree}$\ast$ create\+Node (
\begin{DoxyParamCaption}
\item[{int}]{id, }
\item[{char $\ast$}]{str, }
\item[{{\bf Tree} $\ast$}]{left, }
\item[{{\bf Tree} $\ast$}]{right}
\end{DoxyParamCaption}
)}\hypertarget{tree_8c_a801c4516159f77c6d1e5737d85f8aa1f}{}\label{tree_8c_a801c4516159f77c6d1e5737d85f8aa1f}


Create a new node (tree) 


\begin{DoxyParams}[1]{Parameters}
 & {\em id} & Id of the value to store in the Node \\
\hline
 & {\em str} & String that represents the real name of what is stored \\
\hline
\mbox{\tt in}  & {\em left} & The left child \\
\hline
\mbox{\tt in}  & {\em right} & The right child\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A new Tree 
\end{DoxyReturn}
\index{tree.\+c@{tree.\+c}!free\+Tree@{free\+Tree}}
\index{free\+Tree@{free\+Tree}!tree.\+c@{tree.\+c}}
\subsubsection[{\texorpdfstring{free\+Tree(\+Tree $\ast$t)}{freeTree(Tree *t)}}]{\setlength{\rightskip}{0pt plus 5cm}void free\+Tree (
\begin{DoxyParamCaption}
\item[{{\bf Tree} $\ast$}]{t}
\end{DoxyParamCaption}
)}\hypertarget{tree_8c_a69fb3a3292bd8c145020d0fe58af26ba}{}\label{tree_8c_a69fb3a3292bd8c145020d0fe58af26ba}


Remove from the memory, the space used by the tree. 


\begin{DoxyParams}{Parameters}
{\em t} & Pointer of the tree \\
\hline
\end{DoxyParams}
\index{tree.\+c@{tree.\+c}!is\+Leaf@{is\+Leaf}}
\index{is\+Leaf@{is\+Leaf}!tree.\+c@{tree.\+c}}
\subsubsection[{\texorpdfstring{is\+Leaf(\+Tree $\ast$t)}{isLeaf(Tree *t)}}]{\setlength{\rightskip}{0pt plus 5cm}int is\+Leaf (
\begin{DoxyParamCaption}
\item[{{\bf Tree} $\ast$}]{t}
\end{DoxyParamCaption}
)}\hypertarget{tree_8c_a13511abcf3d362ccaf18d3a8288e9a9c}{}\label{tree_8c_a13511abcf3d362ccaf18d3a8288e9a9c}


Check if a tree is a leaf. 


\begin{DoxyParams}{Parameters}
{\em t} & The tree to check\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 (false) ou 1 (true) 
\end{DoxyReturn}
\index{tree.\+c@{tree.\+c}!L\+CA@{L\+CA}}
\index{L\+CA@{L\+CA}!tree.\+c@{tree.\+c}}
\subsubsection[{\texorpdfstring{L\+C\+A(\+Tree $\ast$root, int id1, int id2)}{LCA(Tree *root, int id1, int id2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tree}$\ast$ L\+CA (
\begin{DoxyParamCaption}
\item[{{\bf Tree} $\ast$}]{root, }
\item[{int}]{id1, }
\item[{int}]{id2}
\end{DoxyParamCaption}
)}\hypertarget{tree_8c_a0a7a9c4c37381d59c0c406c8ce670a9c}{}\label{tree_8c_a0a7a9c4c37381d59c0c406c8ce670a9c}


Find the lowest common ancestor -\/ Complexity θ(n)  We traverse from root to leaf(s). When we find a node matching at least one, we pass it to its parent. The parent tests if left or right child contains the value. If yes, the parent is the L\+CA, else, we pass its parent, up to root. What is pass is the lower node or N\+U\+LL. 


\begin{DoxyParams}{Parameters}
{\em root} & The root of the tree \\
\hline
{\em id1} & The first value \\
\hline
{\em id2} & The second value\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The lowest common ancestor (node or leaf) 
\end{DoxyReturn}
